function prefixSchemaToErrors(yupErrors, transformErrors) {
  const schema = /* @__PURE__ */ new Map();
  for (const yupError of yupErrors) {
    if (!yupError.path) continue;
    const path = yupError.path;
    schema.set(path, (schema.get(path) ?? []).concat(yupError));
  }
  const transformedSchema = {};
  schema.forEach((value, key) => {
    transformedSchema[key] = transformErrors(value);
  });
  return transformedSchema;
}
function defaultFormTransformer(transformErrors) {
  return (zodErrors) => ({
    form: transformErrors(zodErrors),
    fields: prefixSchemaToErrors(zodErrors, transformErrors)
  });
}
const yupValidator = (params = {}) => () => {
  const transformFieldErrors = params.transformErrors ?? ((errors) => errors.map((error) => error.message).join(", "));
  const getTransformStrategy = (validationSource) => validationSource === "form" ? defaultFormTransformer(transformFieldErrors) : transformFieldErrors;
  return {
    validate({ value, validationSource }, fn) {
      try {
        fn.validateSync(value, { abortEarly: false });
        return;
      } catch (_e) {
        const e = _e;
        const transformer = getTransformStrategy(validationSource);
        return transformer(e.inner);
      }
    },
    async validateAsync({ value, validationSource }, fn) {
      try {
        await fn.validate(value, { abortEarly: false });
        return;
      } catch (_e) {
        const e = _e;
        const transformer = getTransformStrategy(validationSource);
        return transformer(e.inner);
      }
    }
  };
};
export {
  defaultFormTransformer,
  prefixSchemaToErrors,
  yupValidator
};
//# sourceMappingURL=validator.js.map
